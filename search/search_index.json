{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ezEDR ezEDR is a drop in solution for quickly getting started with event sourcing. The source code of this project can be found here . Why ezEDR? Event sourcing is a design pattern where the application state is stored as a series of events in an append only log, rather than in a mutable store as it is done in other models such as regular CRUD applications. This has a few benefits over the traditional approach. When the system is designed right, almost no logic is taking place before any event is written to the log. The log is the source of truth and the state is calculated from this source after it has been persisted. This means that the state of the system, and it's history, is very transparent. It is easy to understand why some aggregate has reached a particular state. The system becomes easy to debug! we can replay all events to rebuild the current state. This means that we can add new business logic to historical events. We can even correct bugs and replay the entire system. The system becomes more future proof and even has some self healing aspects. we get audit logging for free! business logic tends to end up in the service layer rather than in the database layer. The business logic, which probably is your most important code, ends up in our version control where it should be. Testing important logic thereby becomes a lot easier and (arguably) more fun to code! There are however some drawbacks as well. In particular, setting up event sourced systems can be difficult, often requires more upfront design decisions in the beginning and the time to \"get something working\" may be significantly longer that with other approaches. This is what ezEDR is trying to solve! How it works ezEDR is an event store for aggregates. Events are stored with an AggregateId and a Version . The system will guarantee that the combination of the EventName , the AggregateId and the Version is unique. This leaves room for a lot of flexibility when designing a system for end users. Example Alice and Bob are working with a system where they are registering customers for their company. The system is using ezEDR under the hood. Register a new aggregate Alice begins her day with registering a new customer. To do that she fills in a form with the customer's name , address and phone number and hits the Save button. This will trigger a sequence of actions: sequenceDiagram autonumber User ->> +App : Post form App ->> +ezEDR : Create event ezEDR ->> +Store : Create aggregate and persist event Store -->> -ezEDR : Success ezEDR -->> -App : Return AggregateId and Version App -->> -User: Success Fill in form and hit Save button Post event CUSTOMER_CREATED Try to persist event with EventName=CUSTOMER_ADDRESS_CREATED , AggregateId=123 and Version=0 Success Return the AggregateId and Version Success The store now have one record with AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456 Update/patch aggregate Alice now realize that she added the wrong phone number. It has to be updated! Alice updates the field The app creates the event CUSTOMER_PHONE_NUMBER_UPDATED with the value 23456 and posts that to ezEDR ezEDR persists the event based on the current version, which is now 0 The event is successfully persisted and the version is incremented to 1 ezEDR returns the new version number along with the AggregateId The app responds back to Alice that the action was successful. The store now contains two records AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456 123 CUSTOMER_PHONE_NUMBER_UPDATED 1 phone:234567 Read an aggregate Bob is also working with the same customer. He opens the customer page to read the customer aggregate: Bob requests the aggregate with AggregateId=123 The propagates this command to ezEDR ezEDR fetches all events associated with the aggregate The storage backend returns the events The app is reducing all the events to one aggregated view. This is we expect to find most of the business logic. Return the aggregated view where to Bob. The current state of the aggregate and the aggregated view in this example is now name: John Smith;street:John's Avenue;phone:234567 . Concurrent updates Alice and Bob now both have a view of the aggregate (customer address) with Version=1 in front of them. Alice realize that she has forgot to add John's middle name, which is Allen. At the same time Bob notice that the address is missing the street number, which is 12. They both updates the value at the same time. When Alice is updating the customer name an event called CUSTOMER_NAME_UPDATED is created by the app and posted to ezEDR with Version=1 . At the same time the app is creating the event CUSTOMER_STREET_UPDATED with Version=1 from Bob's update. One request must hit the server before the other, so let us suppose that Alice's request won the race. Whoever got first in this case doesn't matter. Both requests will succeed, even though Bob's request is based on an outdated version , since ezEDR only leaves the guarantee that the combination of AggregateId , EventName and Version must be unique . This is exactly what we want! If we play our cards right, we will have a system with optimistic concurrency that is very tolerant to change at a very low risk of conflicts due to updates. This will make our users happy. The app will in this case receive a response with AggregateId=123 and Version=2 from Alice's request and a response with AggregateId=123 and Version=3 from Bob's request. The current state is now AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456 123 CUSTOMER_PHONE_NUMBER_UPDATED 1 phone:234567 123 CUSTOMER_NAME_UPDATED 2 name:John Allen Smith 123 CUSTOMER_STREET_UPDATED 3 street:John's Avenue 12 Conclusion The combination of AggregateId , EventName and Version must be unique! This leads to the following properties if ezEDR: Optimistic concurrency with low risk of conflicts A gap in the version sequence (e.g. caused by a conflict) doesn't matter since updating an aggregate based on an old version is fine as long as the guarantee by ezEDR is satisfied.","title":"Home"},{"location":"#ezedr","text":"ezEDR is a drop in solution for quickly getting started with event sourcing. The source code of this project can be found here .","title":"ezEDR"},{"location":"#why-ezedr","text":"Event sourcing is a design pattern where the application state is stored as a series of events in an append only log, rather than in a mutable store as it is done in other models such as regular CRUD applications. This has a few benefits over the traditional approach. When the system is designed right, almost no logic is taking place before any event is written to the log. The log is the source of truth and the state is calculated from this source after it has been persisted. This means that the state of the system, and it's history, is very transparent. It is easy to understand why some aggregate has reached a particular state. The system becomes easy to debug! we can replay all events to rebuild the current state. This means that we can add new business logic to historical events. We can even correct bugs and replay the entire system. The system becomes more future proof and even has some self healing aspects. we get audit logging for free! business logic tends to end up in the service layer rather than in the database layer. The business logic, which probably is your most important code, ends up in our version control where it should be. Testing important logic thereby becomes a lot easier and (arguably) more fun to code! There are however some drawbacks as well. In particular, setting up event sourced systems can be difficult, often requires more upfront design decisions in the beginning and the time to \"get something working\" may be significantly longer that with other approaches. This is what ezEDR is trying to solve!","title":"Why ezEDR?"},{"location":"#how-it-works","text":"ezEDR is an event store for aggregates. Events are stored with an AggregateId and a Version . The system will guarantee that the combination of the EventName , the AggregateId and the Version is unique. This leaves room for a lot of flexibility when designing a system for end users.","title":"How it works"},{"location":"#example","text":"Alice and Bob are working with a system where they are registering customers for their company. The system is using ezEDR under the hood.","title":"Example"},{"location":"#register-a-new-aggregate","text":"Alice begins her day with registering a new customer. To do that she fills in a form with the customer's name , address and phone number and hits the Save button. This will trigger a sequence of actions: sequenceDiagram autonumber User ->> +App : Post form App ->> +ezEDR : Create event ezEDR ->> +Store : Create aggregate and persist event Store -->> -ezEDR : Success ezEDR -->> -App : Return AggregateId and Version App -->> -User: Success Fill in form and hit Save button Post event CUSTOMER_CREATED Try to persist event with EventName=CUSTOMER_ADDRESS_CREATED , AggregateId=123 and Version=0 Success Return the AggregateId and Version Success The store now have one record with AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456","title":"Register a new aggregate"},{"location":"#updatepatch-aggregate","text":"Alice now realize that she added the wrong phone number. It has to be updated! Alice updates the field The app creates the event CUSTOMER_PHONE_NUMBER_UPDATED with the value 23456 and posts that to ezEDR ezEDR persists the event based on the current version, which is now 0 The event is successfully persisted and the version is incremented to 1 ezEDR returns the new version number along with the AggregateId The app responds back to Alice that the action was successful. The store now contains two records AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456 123 CUSTOMER_PHONE_NUMBER_UPDATED 1 phone:234567","title":"Update/patch aggregate"},{"location":"#read-an-aggregate","text":"Bob is also working with the same customer. He opens the customer page to read the customer aggregate: Bob requests the aggregate with AggregateId=123 The propagates this command to ezEDR ezEDR fetches all events associated with the aggregate The storage backend returns the events The app is reducing all the events to one aggregated view. This is we expect to find most of the business logic. Return the aggregated view where to Bob. The current state of the aggregate and the aggregated view in this example is now name: John Smith;street:John's Avenue;phone:234567 .","title":"Read an aggregate"},{"location":"#concurrent-updates","text":"Alice and Bob now both have a view of the aggregate (customer address) with Version=1 in front of them. Alice realize that she has forgot to add John's middle name, which is Allen. At the same time Bob notice that the address is missing the street number, which is 12. They both updates the value at the same time. When Alice is updating the customer name an event called CUSTOMER_NAME_UPDATED is created by the app and posted to ezEDR with Version=1 . At the same time the app is creating the event CUSTOMER_STREET_UPDATED with Version=1 from Bob's update. One request must hit the server before the other, so let us suppose that Alice's request won the race. Whoever got first in this case doesn't matter. Both requests will succeed, even though Bob's request is based on an outdated version , since ezEDR only leaves the guarantee that the combination of AggregateId , EventName and Version must be unique . This is exactly what we want! If we play our cards right, we will have a system with optimistic concurrency that is very tolerant to change at a very low risk of conflicts due to updates. This will make our users happy. The app will in this case receive a response with AggregateId=123 and Version=2 from Alice's request and a response with AggregateId=123 and Version=3 from Bob's request. The current state is now AggregateId Event Version Data 123 CUSTOMER_CREATED 0 name:John Smith;street:John's Avenue;phone:123456 123 CUSTOMER_PHONE_NUMBER_UPDATED 1 phone:234567 123 CUSTOMER_NAME_UPDATED 2 name:John Allen Smith 123 CUSTOMER_STREET_UPDATED 3 street:John's Avenue 12","title":"Concurrent updates"},{"location":"#conclusion","text":"The combination of AggregateId , EventName and Version must be unique! This leads to the following properties if ezEDR: Optimistic concurrency with low risk of conflicts A gap in the version sequence (e.g. caused by a conflict) doesn't matter since updating an aggregate based on an old version is fine as long as the guarantee by ezEDR is satisfied.","title":"Conclusion"},{"location":"architecture/","text":"Architecture ezEDR is designed around a client/server model where the server acts as a API proxy in front of a database. The server currently provides a simple REST API (intended for internal use) with some logic to enforce optimistic concurrency to the event log. The language specific clients(that are not yet implemented) exist for two reasons: ease of use, it decouples the client code from the API. The second bullet is important as the API may eventually be replaced by some other protocol in the future. Client Language Status Javascript Todo Java Todo Rust Todo Go Todo Python Todo Server Persistance Events must be stored somewhere and it doesn't make sense to build a new database from scratch. Instead, the ezEDR is designed to use a plugable backend for storage. PostgreSQL is used as a storage engine at the time of writing and there are plans for MongoDB and possibly Redis down the road.","title":"Architecture"},{"location":"architecture/#architecture","text":"ezEDR is designed around a client/server model where the server acts as a API proxy in front of a database. The server currently provides a simple REST API (intended for internal use) with some logic to enforce optimistic concurrency to the event log. The language specific clients(that are not yet implemented) exist for two reasons: ease of use, it decouples the client code from the API. The second bullet is important as the API may eventually be replaced by some other protocol in the future.","title":"Architecture"},{"location":"architecture/#client","text":"Language Status Javascript Todo Java Todo Rust Todo Go Todo Python Todo","title":"Client"},{"location":"architecture/#server","text":"","title":"Server"},{"location":"architecture/#persistance","text":"Events must be stored somewhere and it doesn't make sense to build a new database from scratch. Instead, the ezEDR is designed to use a plugable backend for storage. PostgreSQL is used as a storage engine at the time of writing and there are plans for MongoDB and possibly Redis down the road.","title":"Persistance"},{"location":"postgres/","text":"Postgres Backend Postgres specific docs","title":"Postgres Backend"},{"location":"postgres/#postgres-backend","text":"Postgres specific docs","title":"Postgres Backend"},{"location":"server/","text":"Server General docs about server","title":"Server"},{"location":"server/#server","text":"General docs about server","title":"Server"}]}