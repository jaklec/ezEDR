{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ezEDR ezEDR is a drop in solution for quickly getting started with event sourcing. The source code of this project can be found here . Why ezEDR? Event sourcing is a design pattern where the application state is stored as a series of events in an append only log, rather than in a mutable store as it is done in other models such as regular CRUD applications. This has a few benefits over the traditional approach. When the system is designed right, almost no logic is taking place before any event is written to the log. The log is the source of truth and the state is calculated from this source after it has been persisted. This means that the state of the system, and it's history, is very transparent. It is easy to understand why some aggregate has reached a particular state. The system becomes easy to debug! we can replay all events to rebuild the current state. This means that we can add new business logic to historical events. We can even correct bugs and replay the entire system. The system becomes more future proof and even has some self healing aspects. we get audit logging for free! business logic tends to end up in the service layer rather than in the database layer. The business logic, which probably is your most important code, ends up in our version control where it should be. Testing important logic thereby becomes a lot easier and (arguably) more fun to code! There are however some drawbacks as well. In particular, setting up event sourced systems can be difficult, often requires more upfront design decisions in the beginning and the time to \"get something working\" may be significantly longer that with other approaches. This is what ezEDR is trying to solve! How it works ezEDR is an event store for aggregates. Events are stored in streams and stored with Version number. The version number represents a sequence number for that particular stream - or a version of the aggregate i you like. The system will guarantee that no event is appended to the stream based on an outdated version of that aggregate.","title":"Home"},{"location":"#ezedr","text":"ezEDR is a drop in solution for quickly getting started with event sourcing. The source code of this project can be found here .","title":"ezEDR"},{"location":"#why-ezedr","text":"Event sourcing is a design pattern where the application state is stored as a series of events in an append only log, rather than in a mutable store as it is done in other models such as regular CRUD applications. This has a few benefits over the traditional approach. When the system is designed right, almost no logic is taking place before any event is written to the log. The log is the source of truth and the state is calculated from this source after it has been persisted. This means that the state of the system, and it's history, is very transparent. It is easy to understand why some aggregate has reached a particular state. The system becomes easy to debug! we can replay all events to rebuild the current state. This means that we can add new business logic to historical events. We can even correct bugs and replay the entire system. The system becomes more future proof and even has some self healing aspects. we get audit logging for free! business logic tends to end up in the service layer rather than in the database layer. The business logic, which probably is your most important code, ends up in our version control where it should be. Testing important logic thereby becomes a lot easier and (arguably) more fun to code! There are however some drawbacks as well. In particular, setting up event sourced systems can be difficult, often requires more upfront design decisions in the beginning and the time to \"get something working\" may be significantly longer that with other approaches. This is what ezEDR is trying to solve!","title":"Why ezEDR?"},{"location":"#how-it-works","text":"ezEDR is an event store for aggregates. Events are stored in streams and stored with Version number. The version number represents a sequence number for that particular stream - or a version of the aggregate i you like. The system will guarantee that no event is appended to the stream based on an outdated version of that aggregate.","title":"How it works"},{"location":"architecture/","text":"Architecture ezEDR is designed around a client/server model where the server acts as a API proxy in front of a database. The server currently provides a simple REST API (intended for internal use) with some logic to enforce optimistic concurrency to the event log. The language specific clients (that at the time of writing this are not yet implemented) exist for two reasons: ease of use, it decouples the client code from the API. The second bullet is important as the API may eventually be replaced by some other protocol in the future. Client Language Status Javascript Todo Java Todo Rust Todo Go Todo Python Todo Server Persistance Events must be stored somewhere and it doesn't make sense to build a new database from scratch. Instead, the ezEDR is designed to use a plugable backend for storage. PostgreSQL is used as a storage engine at the time of writing and there are plans for MongoDB and possibly Redis down the road.","title":"Architecture"},{"location":"architecture/#architecture","text":"ezEDR is designed around a client/server model where the server acts as a API proxy in front of a database. The server currently provides a simple REST API (intended for internal use) with some logic to enforce optimistic concurrency to the event log. The language specific clients (that at the time of writing this are not yet implemented) exist for two reasons: ease of use, it decouples the client code from the API. The second bullet is important as the API may eventually be replaced by some other protocol in the future.","title":"Architecture"},{"location":"architecture/#client","text":"Language Status Javascript Todo Java Todo Rust Todo Go Todo Python Todo","title":"Client"},{"location":"architecture/#server","text":"","title":"Server"},{"location":"architecture/#persistance","text":"Events must be stored somewhere and it doesn't make sense to build a new database from scratch. Instead, the ezEDR is designed to use a plugable backend for storage. PostgreSQL is used as a storage engine at the time of writing and there are plans for MongoDB and possibly Redis down the road.","title":"Persistance"},{"location":"postgres/","text":"Postgres Backend Postgres specific docs","title":"Postgres Backend"},{"location":"postgres/#postgres-backend","text":"Postgres specific docs","title":"Postgres Backend"},{"location":"server/","text":"Server General docs about server","title":"Server"},{"location":"server/#server","text":"General docs about server","title":"Server"}]}